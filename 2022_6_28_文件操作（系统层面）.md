# Linux下的文件概述

狭义上，文件指的就是磁盘上的文件，又因为磁盘是外设，**对文件的操作本质上可以抽象为对外设的输入输出**，简称IO。

广义上，**linux下一切皆文件**，因为linux的所有内容都以文件的形式进行存储，包括把硬件设备（键盘，显示器，网卡，键盘等）都抽象为文件。

**linux下用结构体描述文件**，所以在操作系统的角度看到的都是一个个的结构体。

对于文件操作，我们应该知道一个空文件也占用了磁盘空间，因为文件不仅仅是内容，还有其自身的属性，即**文件=内容+属性**。所以对文件的操作本质上无外乎两种操作，一种是操作内容，一种是操作属性。

我们以前在语言上学的文件更加关注于操作文件的内容，比如读写文件。以C语言为例，在语言层面上肯定是不足以去操作硬件的，所以C语言提供的有关文件操作的库函数底层肯定是调用了系统接口。

> 从系统的角度来看，对文件的操作本质是**进程对文件的操作**，比如文件操作相关的代码要先生成可执行程序，加载到内存成为一个进程再去执行文件操作。
>
> 磁盘的管理者是操作系统。（毕竟我们最开始就知道用户，也就是**我们不可能直接去操作硬件**，而是借助操作系统给我们的接口。
>
> [知乎大佬对于一切皆文件的理解](https://www.zhihu.com/question/422144033)

# C语言中的文件IO

### 常用的文件操作

库函数用法模糊的直接查文档即可，下面给出几个例子。

#### fopen和fputs

FILE *fopen(const char *path, const char *mode);

![image-20220702161747174](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220702161747174.png)

> w：写入，每次写入都是写入，意味着之前的内容会被清空
>
> a：append，追加，不清空文件内容，在文件最后追加内容，即数据增多。

 int fputs(const char *s, FILE *stream);    函数作用是往文件里写字符串

##### 例子

```c
#include<stdio.h>
int main()
{
  FILE* fp=fopen("./log.txt","w");
  if(fp==NULL)//打开失败
  {
    perror("fopen");
    return 1;
  }
  fputs("hello world\n",fp);
  fclose(fp);
  return 0;
}
```



![image-20220702162447972](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220702162447972.png)



#### fwrite

size_t fwrite(const void *ptr, size_t size, size_t nmemb,FILE *stream);

解释一下这四个参数，第一个参数是一个指针，第二个参数是写入的每个元素的大小，第三个是写入几个元素，第四个是写到哪个文件。简单来说就是从指针指向的位置开始写入size*nmemb个字节。

> 比如把const char* msg="hello world"写到log.txt里面，那就是fwrite(msg,strlen(msg),1,fp)
>
> 这里有个问题，strlen要不要+1？换句话说**写入的字符串里要不要包括‘\0’**?答案是不需要，因为'\0'是C语言的规定，如果我们写入了'\0'就会有乱码，虽然打印文件时这个乱码可能不显示，但确实被写入了文件。

##### 例子

```c
#include<stdio.h>
#include<string.h>

int main()
{
  FILE* fp=fopen("./log.txt","a");
  if(fp==NULL)//打开失败
  {
    perror("fopen");
    return 1;
  }
  const char* msg="ck is a good man!\n";
  fwrite(msg,strlen(msg),1,fp);
  fclose(fp);
  return 0;
}
```

![image-20220702163701116](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220702163701116.png)



#### fgets

 char *fgets(char *s, int size, FILE *stream);

![image-20220702165222286](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220702165222286.png)

> 每个进程都有一个内置属性cwd存储着进程的当前路径
>
> ```c
> #include<stdio.h>
> #include<string.h>
> #include <unistd.h>
> 
> int main()
> {
>   FILE* fp=fopen("./log.txt","r");
>   if(fp==NULL)//打开失败
>   {
>     perror("fopen");
>     return 1;
>   }
>   char  buffer[128];
>   fgets(buffer,128,fp);
>   printf("%s\n",buffer);
>   fclose(fp);
> 
>   while(1)//加个死循环利于观察进程状态
>   {
>     sleep(1);
>   }
>   return 0;
> }
> ```
>
> ![image-20220702170212238](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220702170212238.png) 



### C程序默认打开的文件

先以C语言为例，任何C程序都会默认打开三个文件，分别是标准输入（stdin），标准输出(stdout)，标准错误（stderr）.

> [浅谈scanf、fscanf、sscanf的使用和区别_](https://blog.csdn.net/m0_53005929/article/details/119740505?spm=1001.2014.3001.5502)     博客里有简单介绍这三个文件

![image-20220704091838619](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220704091838619.png)

问问linux里的man这三个是什么。

![image-20220704092052156](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220704092052156.png)

我们其实一直在使用这三个文件，比如printf打印到显示器上，scanf从键盘读取数据，perror打印错误到显示器上，如果没有打开这三个文件，我们是不能直接完成对硬件的操作。

> 不光是C语言，其实几乎所有语言的程序都会默认打开这三个文件，比如C++的cin，cout。

#### 拓展

关于FILE

![image-20220704093140946](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220704093140946.png)



外设不止一种，OS该怎么去管理这么多的文件？先描述再组织。用struct file描述后操作系统再进行组织管理即可。

每个外设的读写方式都不同，用同一种类型(file)该怎样去让他们调用自己的读写呢？提供不同的方法即可。C里面则是以函数指针的形式体现。

![image-20220704103548903](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220704103548903.png)

> 语言上的接口不过是对系统接口的封装，为什么语言不直接调用系统接口？语言为了保证自身生态的完整性，肯定不会去直接调用系统接口，而且直接调用的话不具备可移植性。 比如我在windows系统下调用windows的接口，在linux下肯定就行不通了。但是如果我对其进行封装，比如fopen这个函数，在linux下就调用linux系统给的接口，windows下就调用windows系统的接口。
>
> 同一个头文件不同平台下的实现可能不同。

# Linux下的系统IO

C库函数的底层肯定是调用了系统的接口，现在我们来了解一下系统给的接口。从接口窥探文件特性

## open

基本用法都可以通过man命令完成

int open(const char *pathname, int flags, mode_t mode);

![image-20220704105406140](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220704105406140.png)

返回值是文件描述符，创建失败返回-1.、

> 后面会详细说文件描述符，现在简单理解为这代表一个文件，有点像文件的具体路径可以帮助系统知道要操作哪个文件。

![image-20220704111657611](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220704111657611.png)

> 对参数flags的解释，决定文件以什么方式打开，本质就是一些宏
>
> ![image-20220704105656076](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220704105656076.png)
>
> O_APPEND是追加，但是注意追加针对的是**多次运行程序**，而不是单次运行时的多次写入（从语文上这也叫追加，但是意思不同）。
>
> mode选项用来设置权限。
>
> 比如mode设置为0644，那权限就是-rw-r--r--

## close

![image-20220704112050662](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220704112050662.png)

## write

![image-20220704112433457](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220704112433457.png)

## close

![image-20220704113054319](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220704113054319.png)

## 例子

下面的例子包括了上面四个函数的简单用法

```c
#include <stdio.h>
#include<sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>

int main()
{

  //open
  int fd=open("log.txt",O_RDWR|O_CREAT,0644);
  if(fd==-1)
  {
    perror("open");
    return 1;
  }
    
  //write
  const char* msg="hello world!\n";
  write(fd,msg,strlen(msg));
  //close
  close(fd);
    
  //open+read+close
  int fd2=open("log.txt",O_RDWR|O_CREAT,0644);
  char buffer[128];
  ssize_t len=read(fd,buffer,127);
  if(len>0)
  {
    buffer[len]='\0';
  }
  else 
  {
    perror("read");
  }

  printf("%s",buffer);
  close(fd2);

  return 0;
}
```

这段代码包含了写和读，写完后应该先关闭文件让数据写进文件，后面的read才能生效。如果不关闭直接读就会出现读取成功，但是读不到数据的情况，因为代码运行到read时**数据还在缓冲区**内，直到进程退出或者close才会被刷新到文件内。

> 文件在磁盘上，读写操作都是对磁盘的操作，数据不是直接写到磁盘上，而是先放入缓冲去内，再根据缓冲策略刷新到磁盘。

![image-20220704145613172](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220704145613172.png)

# 文件描述符fd

我们之前知道进程描述符task_struct(PCB),内存描述符mm_struct的存在，这里又出现了一个文件描述符fd。

先给结论：**进程通过文件描述符来访问文件**

回顾一下之前我们已知的进程相关的知识，代码编译链接生成可执行文件，可执行文件加载到内存运行，于是就有了进程，进程创建时系统也创建了相关的数据结构用于**描述进程**，task_struct，task_struct里又有一个指针指向mm_struct，等等。

这个文件描述符也是一样。但文件描述符是一个整形而不是结构体，所以fd显然不足以描述一个文件。事实也确实如此，fd存在于一个名叫files_struct的结构体中，而task_struct里存了一个指向files_struct结构体的指针，files_struct里又维护了一个数组，这个数组描述的是进程与文件的对应关系，数组的下标就是fd，也就是说，**进程通过fd就可以知道这是哪个文件**。

**打开文件的过程是怎么样的？**磁盘上的文件先加载到内存，生成对应的struct file(描述文件的属性和操作)，生成后链入文件双链表，再把这个结构体的地址填入struct files_struct内维护的数组，数组的下标即为fd.

![image-20220704162348808](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220704162348808.png)



> task_struct里的files_struct*的指针
>
> ![image-20220704154620178](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220704154620178.png)
>
> files_struct里维护的对应关系的数组
>
> ![image-20220704152405429](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220704152405429.png)
>
> 数组类型struct file的定义
>
> ![image-20220704155816911](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220704155816911.png)
>
> file里描述的操作。
>
> ![](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220704164129547.png)![](https://pic

## fd的分配原则

找到数组最小的，未使用的进行分配。

比如我close(0)，再open("log.txt",O_RDONLY)，那此时分配给log.txt的fd就是0了

```c
#include <stdio.h>
#include<sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>

int main()
{
  close(0);
  int fd1=open("log.txt",O_RDONLY);

  int fd2=open("log.txt",O_RDONLY);
  int fd3=open("log.txt",O_RDONLY);
  int fd4=open("log.txt",O_RDONLY);
  printf("%d\n",fd1);
  printf("%d\n",fd2);
  printf("%d\n",fd3);
  printf("%d\n",fd4);
  return 0;
}
```

可以看到关掉0后，第一个分配给log.txt的就是0，分配的原则也符合最小的且未使用的。

![image-20220704163556717](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220704163556717.png)

## fd的范围

fd既然是数组下标，那数组是静态的，那这个数组的范围是多少呢？或者说我们在单个进程里可以打开多少个文件？

可以写一个程序验证，也可以用命令（ulimit -n)。

命令验证

![image-20220704154024051](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220704154024051.png)

自己写个程序验证一下

```c
#include <stdio.h>
#include <stdio.h>
#include<sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>

int main()
{
  long long i;
  while(1)
  {
   i=open("log.txt",O_RDONLY);
    if(i<0)
    {
      perror("open");
      exit(0);
    }
    else 
    {
      printf("当前文件的fd为%lld\n",i);
    }
  }
  return 0;
}
```

![image-20220704153658198](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220704153658198.png)

可以看到包括默认打开的三个文件（标准输入、标准输出和标准错误），**一共能打开的就是100001个文件**，环境不同可能结果不同。

## 小结

- 对于进程来说，对所有的文件进行操作使用的是同一套接口（也可以说是同一套的函数指针）。

- **通过文件描述符fd就可以找到文件**，可以知道这个文件的所有细节。

- 这些都是在OS内部的，用户只需要关注fd

> C语言里也有一个对应的fd，因为C库函数本质上还是调用系统接口。















![image-20220703214628108](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220703214628108.png)

close(1)把本来应该显示到显示器上的内容写入到了指定的文件。

这不就是输出**重定向** 

系统默认打开的三个fd就是0 

 1 2



![image-20220703220041641](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220703220041641.png)

![image-20220703220954983](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220703220954983.png)

![image-20220703221043598](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220703221043598.png)









![image-20220703221559946](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220703221559946.png)



 

![image-20220703221933012](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220703221933012.png)





进程退出缓冲区刷新，刷新前把fd关了，导致刷新失败





改的不是1 是1里面的内容

![image-20220703223425821](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220703223425821.png)







![image-20220703223726821](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220703223726821.png)

重定向失败





改变了刷新策略

![image-20220703223910831](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220703223910831.png)



![image-20220703224508867](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220703224508867.png)



















































