进程地址空间本质上是进程看待内存的方式，抽象出来的一个概念，内核就是一个结构体  mm_struct（或者说在linux里通过结构体实现），都认为自己独占系统内存资源

区域划分本质：将线性地址空间划分成一个又一个的area[start,end]；start和end之间的地址就是线性地址



![image-20220625132651466](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220625132651466.png)



操作系统给进程画了一张饼，这张饼就是进程地址空间（操作系统让进程以为自己拥有整个物理内存），实际上进程拥有的只是虚拟地址。

我们常常把进程地址空间比作一把尺子，根据尺子刻度来划分空间

进程和进程地址空间是通过指针进行联系的（比如task_struct里面存一个指向mm_struct的指针）



页表：完成虚拟地址到物理地址之间的映射（需要配合硬件

虚拟地址可以完全一样，映射到的物理内存不同即可

写时拷贝，数据的物理地址一样，但是一旦修改就开一块空间进行拷贝数据。

![image-20220625135019200](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220625135019200.png)



![image-20220625163826940](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220625163826940.png)



页表



4GB能不能运行16GB的游戏？

![image-20220625164659036](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220625164659036.png)



可执行程序，本身就已经划分成为了一个个的区域

![image-20220625170135578](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220625170135578.png)

![image-20220625173531124](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220625173531124.png)



进程控制

进程的创建

![image-20220626094806037](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220626094806037.png)



操作系统创建进程 给我们的接口是fork()

创建子进程本质是系统多了一个进程（进了调度列表），本质就是多了一套进程相关的数据结构

在不写入的情况下，用户的代码和数据是父子共享的

if和else if同时执行

fork的相关问题

fork之后父子进程都有pid，因为返回值不同发生了写时拷贝

并不是return两次 而是值写入引起了写时拷贝  （页表映射的物理内存不是同一块）



![image-20220626101517785](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220626101517785.png)

为什么要有写时拷贝  保证父子进程的独立性

![image-20220626120017647](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220626120017647.png)

fork常规用法即调用失败的原因。



进程终止

main中为什么需要写return 0？

echo $? 查看最近一次执行程序的退出码

![image-20220626121601245](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220626121601245.png)

![image-20220626121635839](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220626121635839.png)



进程退出的情况分类

退出码可以人为定义，也可以用系统提供的错误码列表

比如C语言提供的strerror（在vim界面下怎么查询函数）



父进程想知道子进程有没有完成任务

进程异常结束

![image-20220626163830322](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220626163830322.png)



exit和_exit的区别



所有的进程都是操作系统创建的



为什么要等待

![image-20220626211923453](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220626211923453.png)

![image-20220626212406799](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220626212406799.png)



![image-20220626215808453](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220626215808453.png)

![image-20220626221431635](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220626221431635.png)

![image-20220626222104848](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220626222104848.png)

如果不wait会怎么样？



输出型参数status

为什么要通过waitpid拿到子进程的结果  我能不能用全局变量

![image-20220626224044068](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220626224044068.png)

退出码的前提是正常终止

![image-20220626232205403](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220626232205403.png)
