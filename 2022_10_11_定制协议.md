[toc]

# å¼•è¨€

ç†è§£ç½‘ç»œåè®®é‡Œçš„åè®®äºŒå­—,åè®®çš„æœ¬è´¨å°±æ˜¯ä¸€ç§çº¦å®š.

ä¸‹é¢å€ŸåŠ©ç½‘ç»œç‰ˆæœ¬çš„è®¡ç®—å™¨æ¥è¯´æ˜.

# ç½‘è·¯ç‰ˆçš„è®¡ç®—å™¨

## æ³¨é‡Š

| æ–‡ä»¶         | ä½œç”¨                                           |
| ------------ | ---------------------------------------------- |
| Makefile     | è‡ªåŠ¨ç¼–è¯‘                                       |
| protocol.hpp | æè¿°æˆ‘ä»¬è‡ªå·±å®šåˆ¶çš„åè®®                         |
| server.hpp   | socketç¼–ç¨‹,çœå»äº†åºåˆ—åŒ–çš„è¿‡ç¨‹,ç›´æ¥recvå’Œsend   |
| clinet.hpp   | socketç¼–ç¨‹,çœå»äº†ååºåˆ—åŒ–çš„è¿‡ç¨‹,ç›´æ¥recvå’Œsend |
| server.cc    | mainå‡½æ•°                                       |
| client.cc    | mainå‡½æ•°                                       |

socketç¼–ç¨‹å°±ä¸è¯¦ç»†è§£é‡Šäº†,æœ‰ç‚¹å¥—è·¯åŒ–,å…·ä½“çš„å¯ä»¥çœ‹è¿™ç¯‡ğŸ‘‰[socketç¼–ç¨‹_](https://blog.csdn.net/m0_53005929/article/details/127264644?spm=1001.2014.3001.5501)

## Makefile

```makefile
.PHONY:all
all: client server

client:client.cc
	g++ -o $@ $^ -std=c++11

server:server.cc
	g++ -o $@ $^ -std=c++11 -lpthread

.PHONY:clean
clean:
	rm -f client server
```

## protocol.hpp

```cpp
#include <iostream>

namespace  ns_protocol
{
  struct Request
  {
    int x;
    int y;
    char op;//"+-*/%"

    Request()
      :x(0)
      ,y(0)
      ,op('+')
    {

    }
  };

  struct Response
  {
    int code;//çŠ¶æ€ç  0è¡¨ç¤ºæˆåŠŸ,å…¶ä½™è¡¨ç¤ºé”™è¯¯
    int result;//è®¡ç®—åçš„ç»“æœ

    Response()
      :code(0)
      ,result(-1)
    {

    }
  };

}
```

## server.hpp

```cpp
#include<iostream>
#include <unistd.h>
#include<sys/types.h>
#include <sys/socket.h>
#include<netinet/in.h>
#include <strings.h>
#include <arpa/inet.h>
#include <pthread.h>
#include <stdlib.h>
#include "protocol.hpp"

namespace ns_server
{
  class Server
  {
    private:
      uint16_t port;
      int listen_sock;

    public:
      Server(uint16_t _port)
        :port(_port)
        ,listen_sock(-1)
      {

      }
      void InitServer()
      {
        //åˆ›å»ºå¥—æ¥å­—
        listen_sock=socket(AF_INET,SOCK_STREAM,0);
        if(listen_sock<0)
        {
          std::cerr<<"listen_sock err\n";
          exit(2);
        }
        //ç»‘å®šç«¯å£
        sockaddr_in local;
        socklen_t len=sizeof(local);
        bzero(&local,len);
        local.sin_family=AF_INET;
        local.sin_port=htons(port);
        local.sin_addr.s_addr=INADDR_ANY;
        if(bind(listen_sock,(struct sockaddr*)&local,len)<0)
        {
          std::cerr<<"bind err\n";
          exit(3);
        }

        //ç›‘å¬,åˆ›å»ºé“¾æ¥
        if(listen(listen_sock,5)<0)
        {
          std::cerr<<"listen err\n";
          exit(5);
        }
        

      }

      static void* calc(void* args)
      {
        pthread_detach(pthread_self());
        int sock=*(int*)args;
        delete (int*)args;
        while(true)
        {
          ns_protocol::Request request;
          ssize_t s=recv(sock,&request,sizeof(request),0);
          if(s<0)
          {
            std::cerr<<"recv err,client quit,me too\n";
            break;
          }
          else if(s==0)//å…³é—­å®¢æˆ·ç«¯å°±èµ°è¿™é‡Œ
          {
            std::cout<<"recv end,client quit,me too\n";
            break;
          }
          else 
          {
            //æ‹¿åˆ°request
            ns_protocol::Response resp;
            switch(request.op)
            {
              case '+':
                resp.result=request.x+request.y;
                break;
              case '-':
                resp.result=request.x-request.y;
                break;
              case '*':
                resp.result=request.x*request.y;
                break;
              case '/':
                if(request.y==0)
                {
                  resp.code=2;
                }
                else 
                {
                  resp.result=request.x/request.y;
                }
                break;
              case '%':
                if(request.y==0)
                {
                  resp.code=3;
                }
                else 
                {
                 resp.result=request.x%request.y;
                }
                break;
              default:
                resp.code=-1;//æ“ä½œå¤±è¯¯
                break;
            }
            send(sock,&resp,sizeof(resp),0);
          }

        }
      close(sock);
       return nullptr;
      }
      void Loop()
      {
    
        while(true)
        {
          
          struct sockaddr_in peer;
          socklen_t len_peer=sizeof(peer);//ä¸èƒ½æ˜¯nullptr
          bzero(&peer,sizeof(peer));
  
          //è·å–é“¾æ¥
          int sock=accept(listen_sock,(struct sockaddr*)&peer,&len_peer);
          if(sock<0)
          {
            std::cerr<<"accept err\n";
            // exit(6);//å®¢æˆ·ç«¯æ²¡è¿ä¸Šåº”è¯¥continueè€Œä¸æ˜¯æœåŠ¡å™¨é€€å‡º,å› ä¸ºé“¾æ¥å¾ˆé¢‘ç¹
            continue;
          }
          //æ‹¿åˆ°sockååˆ›å»ºçº¿ç¨‹å»å¤„ç†
          pthread_t tid;
          int* p=new int(sock);
          pthread_create(&tid,nullptr,calc,p);


        }
      }

      ~Server()
      {
        if(listen_sock>=0)
        {
          close(listen_sock);
        }
      }
  };


}
```



## clinet.hpp

```cpp
#include<iostream>
#include <unistd.h>
#include<sys/types.h>
#include <sys/socket.h>
#include<netinet/in.h>
#include <strings.h>
#include <arpa/inet.h>
#include <pthread.h>
#include <stdlib.h>
#include "protocol.hpp"
#include <string>

namespace ns_client
{
  class Client
  {
    private:
      int sock;
      uint16_t port;
      std::string ip;

    public:
      Client(std::string _ip,uint16_t _port)
        :sock(-1)
        ,port(_port)
        ,ip(_ip)
      {
        
      }
      void InitClient()
      {
        sock=socket(AF_INET,SOCK_STREAM,0);
        if(sock<0)
        {
          std::cerr<<"sock err\n";
          exit(2);
        }
        //ä¸éœ€è¦ç»‘å®š,ç›´æ¥é“¾æ¥æœåŠ¡å™¨
      }
      
      void Run()
      {

          //connect

          struct sockaddr_in peer;
          socklen_t len=sizeof(peer);
          bzero(&peer,len);
          peer.sin_family=AF_INET;
          peer.sin_port=htons(port);
          peer.sin_addr.s_addr=inet_addr(ip.c_str());
           
          if(connect(sock,(sockaddr*)&peer,len)<0)
          {
            std::cerr<<"connect err\n";
            exit(3);//æ²¡è¿æ¥ä¸Šç›´æ¥é€€å‡º
          }

          while(true)
          {
            ns_protocol::Request request;
            std::cout<<"è¯·è¾“å…¥ç¬¬ä¸€ä¸ªæ•°->";
            std::cin>>(request.x);
            std::cout<<"è¯·è¾“å…¥ç¬¬äºŒä¸ªæ•°->";
            std::cin>>(request.y);
            std::cout<<"è¯·è¾“å…¥æ“ä½œç¬¦(+-*/%)->";
            std::cin>>(request.op);
            send(sock,&request,sizeof(request),0);


            ns_protocol::Response resp;
            ssize_t s=recv(sock,&resp,sizeof(resp),0);
            if(s>0)
            {
              std::cout<<"code: "<<resp.code<<"\n";
              std::cout<<"result: "<<resp.result<<"\n";
            }
          }
          
      }
      ~Client()
      {
        if(sock>=0)
        {
          close(sock);
        }
      }

  };

}
```



## server.cc

```cpp
#include "server.hpp"

void Usage(char* proc)
{
  std::cout<<"Usage:\n\t"<<proc<<" local_port\n"; 
}

int main(int argc,char* argv[])
{
  if(argc!=2)
  {
    Usage(argv[0]);
    return 2;
  }
  ns_server::Server svr(atoi(argv[1]));
  svr.InitServer();
  svr.Loop();

  return 0;
}
```





## client.cc

```cpp
#include "client.hpp"

void Usage(char* proc)
{
  std::cout<<"Usage\n\t"<<proc<<" peer_ip peer_port\n";
}
int main(int argc,char* argv[])
{
  if(argc!=3)
  {
    Usage(argv[0]);
    return 1;
  }

  ns_client::Client cli(argv[1],atoi(argv[2]));
  cli.InitClient();
  cli.Run();

  return 0;
}

```

## è¿è¡Œæ•ˆæœ

![ç½‘ç»œç‰ˆæœ¬çš„è®¡ç®—å™¨](https://ccl-1304888003.cos.ap-guangzhou.myqcloud.com/img/%E7%BD%91%E7%BB%9C%E7%89%88%E6%9C%AC%E7%9A%84%E8%AE%A1%E7%AE%97%E5%99%A8.gif)



> XShell:ctrl+shift+Téšè—çª—å£æ ‡ç­¾

# æ€è€ƒ

æˆ‘ä»¬å…ˆçœ‹ä¸€ä¸‹protocol.hppçš„å†…å®¹

```cpp
#include <iostream>

namespace  ns_protocol
{
  struct Request
  {
    int x;
    int y;
    char op;//"+-*/%"

    Request()
      :x(0)
      ,y(0)
      ,op('+')
    {}
  };

  struct Response
  {
    int code;//çŠ¶æ€ç  0è¡¨ç¤ºæˆåŠŸ,å…¶ä½™è¡¨ç¤ºé”™è¯¯
    int result;//è®¡ç®—åçš„ç»“æœ

    Response()
      :code(0)
      ,result(-1)
    {

    }
  };

}
```

struct Requesté‡Œçš„xæ˜¯ä»€ä¹ˆ?yæ˜¯ä»€ä¹ˆ?opæ˜¯ä»€ä¹ˆ?

å‡å¦‚æˆ‘ä»¬è¾“å…¥çš„opæ˜¯'/',ä¸ºä»€ä¹ˆä¸€å®šæ˜¯x/y?ä¸èƒ½æ˜¯y/x?

 struct Responseé‡Œçš„codeåˆæ˜¯å•¥?resultåˆæ˜¯å•¥?å„è‡ªä»£è¡¨ä»€ä¹ˆå«ä¹‰?

æˆ‘ä»¬èƒ½æ­£å¸¸ä½¿ç”¨è¿™ä¸ªç½‘ç»œç‰ˆçš„è®¡ç®—å™¨,å› ä¸ºè¿™æ˜¯æˆ‘ä»¬è‡ªå·±å®šåˆ¶çš„åè®®,æˆ‘ä»¬è§„å®šä¸€å®šæ˜¯x/y,è§„å®šçŠ¶æ€ç codeä¸º0å°±è¡¨ç¤ºæˆåŠŸ.

ç½‘ç»œè®¡ç®—å™¨é‡Œçš„åè®®æ˜¯æˆ‘é’ˆå¯¹å…·ä½“çš„åœºæ™¯è®¾è®¡çš„åè®®,å¯æ‰©å±•æ€§å’Œå¥å£®æ€§ä¸è¶³.

åœ¨äº’è”ç½‘é‡Œé¢æœ‰ä¸€äº›é«˜é¢‘åœºæ™¯,æ‰€ä»¥æœ‰å¾ˆå¤šå¤§ä½¬å·²ç»ç»™æˆ‘ä»¬åšå¥½äº†å¾ˆå¤šåº”ç”¨å±‚çš„åè®®,æˆ‘ä»¬å°±ä¸ç”¨è‡ªå·±è®¾è®¡åè®®äº†,åªéœ€è¦å­¦ä¹ äº†è§£ä»–ä»¬å®šåˆ¶çš„åè®®å°±å¥½äº†.æ¯”å¦‚httpåè®®,æ‰€ä»¥ä¹‹åæˆ‘ä»¬çš„ä»»åŠ¡å°±æ˜¯å­¦ä¹ äº†è§£ä¸€äº›å¸¸ç”¨åè®®,ç„¶åè‡ªå·±å¯ä»¥ç¼–å†™å°éƒ¨åˆ†åè®®.

å½“ç„¶ä¸æ’é™¤ä¸€äº›ç‰¹æ®Šåœºæ™¯éœ€è¦æˆ‘ä»¬è‡ªå·±å†™åè®®,æ¯”å¦‚æ¸¸æˆé¢†åŸŸ.

