

[toc]



# 🌲进程通信引论

## 🌴概念

进程通信是指在进程间传输数据(交换信息)。--百度百科

> 人与人之间的通信是什么？交换信息。进程之间的信息是什么？是数据！所以**进程通信可以理解为进程之间传递数据。**
>
> **IPC**(InterProcess Communicatio)是进程间通信的简称。

进程通信要做的事可以理解为让多个进程看到同一块资源。

## 🌴目的

进程通信的目的

- 数据传输：一个进程发送数据给另一个进程，数据量在一个字节到几M字节之间
- 共享数据：多个进程共享同一块资源，做到这点需要内核提供同步和互斥机制。
- 通知事件：一个进程向另一个进程发消息，比如一个进程结束时应该通知其父进程
- 进程控制：一个进程完全控制另一个进程，如debug进程。

> 这些听起来都太抽象了，联系实际场景才能理解。

## 🌴本质

进程通信的本质就是**让多个进程看到同一块资源**。

> 这块资源常指的是内存资源，在linux下一切皆文件，所以也可以理解成文件资源。
>
> 进程通信的方式也是围绕着这一句话展开的。

## 🌴分类

System V和POSIX我理解为不同的标准。

![image-20220720154922782](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220720154922782.png)

我们主要了解匿名管道、命名管道、共享内存和信号量，通信方式不同，自然通信策略也不同。

> [System v 和 Posix作用和区别（进程间通信IPC）_山农的博客-CSDN博客_system v](https://blog.csdn.net/return_cc/article/details/78417642)
>
> System V是Unix系统的某个版本。Posix是由IEEE和ISO开发的一套标准，两个都可以说是一种系统接口的协议。

# 🌲管道

## 🌴管道概念

管道是一种常见的进程通信工具。

Linux里的管道命令是'|'。

```shell
ls -l | grep *.txt
```

![image-20220720162349474](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220720162349474.png)![image-20220720164405847](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220720164405847.png)

## 🌴为什么需要管道

我们为什么需要管道，或者说两个进程间能直接传递数据吗？因为进程间不能直接通信，每个进程都是独立的，进程有自己的地址空间，如果两个进程直接传递数据，会发生写时拷贝。所以此时我们需要一个媒介，也就是这里讲的管道。借助管道我们可以实现两个进程之间的单向通信。

> 所以管道的作用自然也就出来了，管道的作用就是让两个进程看到同一份资源,这个资源常常指的是内存资源，也可抽象为文件资源。

![image-20220720161823499](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220720161823499.png)

![image-20220720161833247](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220720161833247.png)

## 🌴匿名管道

匿名管道用于有亲子关系的进程，常见于父子也可以用于兄弟等。

![image-20220720170746651](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220720170746651.png)

- 管道实现形态上是文件，但是管道本身不占用磁盘或其他外部存储的空间--摘自知乎。

- 管道文件的内容在内存的缓冲区上，缓冲区的内容不会刷新到磁盘的文件上

  > 个人认为是没必要刷新到磁盘上，从内存读取的速度比从从磁盘上快的多，管道传输数据也是单向的，数据被接收的进程读取后没必要刷新到磁盘上。硬要刷新到磁盘上的话那没必要用管道...让这两个进程加载磁盘上的同一个文件不就行了。
  >
  > [大佬对于管道的一些理解](http://bbs.chinaunix.net/thread-314244-1-1.html)，从中摘录一段话：作为管道，一旦创建成功，应用除了传递数据外，能够做的只有删除操作了。

### 🥝创建匿名管道

匿名管道用于两个有亲缘关系的进程之间的单向通信，比如父进程写子进程读。如果有多个进程需要通信，那就建立多个管道。

#### 🥝pipe函数

 int pipe(int pipefd[2]);

传入参数为一个数组，也是输出型参数，pipefd[0]放管道的读端文件描述符，pipefd[1]放管道的写端文件描述符

![image-20220720161833247](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220720220833958.png)

pipe函数的作用

![image-20220720224446834](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220720224446834.png)

> 这里的箭头表示指针指向，而不是数据流向

pipe结合fork之后的图

![image-20220720225237600](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220720225237600.png)

**父子进程通过关闭文件描述符来实现管道的单向通信**

对管道里面写入数据的操作，和对文件里写入数据的操作一样，印证了Linux下的一切皆文件。

管道是单向的，肯定是一个写一个读。所以建议写之前关闭读，读之前关闭写

> 既然是写之前要关闭读，读之前要关闭写，那一开始为什么还要打开读写呢，只打开读或者只打开写不就行了吗。因为父子进程拿到的文件打开方式是一样的，如果父进程只打开读那子进程也只能读，也就不能写了，我们有提到管道肯定是一个写一个读，所以父进程打开文件的方式肯定是读写（rw）。
>
> 为什么建议读之前关闭写，写之前关闭读？防止误操作。

下面的代码：父进程创建管道，父进程创建子进程，子进程在管道里每隔1s写入一次数据，父进程去读。

```c
#include <stdio.h>
#include<unistd.h>
#include<string.h>
#include <stdlib.h>
#include<sys/types.h>
#include <sys/wait.h>
int main()
{
  int pipe_fd[2]={0};
  int ret=pipe(pipe_fd);
  if(ret<0)
  {
    perror("pipe");
    return 1;
  }
  pid_t id=fork();
  if(id==0)
  {
    //child write
    close(pipe_fd[0]);//写之前关闭读
    int cnt=5;
    const char* msg="hello world!\n";
    while(cnt--)
    {
      write(pipe_fd[1],msg,strlen(msg));
      sleep(1);
    }
    close(pipe_fd[1]);
    exit(0);
  }
  else if(id>0)
  {
    //father read 
    close(pipe_fd[1]);//读之前关闭写
    char buffer[128];
    while(1)
    {
      ssize_t num=read(pipe_fd[0],buffer,127);//读到几个字节
      if(num>0)
      {
        buffer[num]='\0';
        printf("father get the msg from child:%s\n",buffer);
      }
      else if(num==0) 
      {
        printf("piple file close,child quit\n");
        break;
      }
      else 
      {
        perror("read");
      }
    }
    close(pipe_fd[0]);
    int status=0;
    if(waitpid(id,&status,0)>0)
    {
      printf("wait success!\n");
    }
  }
  else 
  {
    perror("fork");
  }
  return 0;
}
```

运行效果

![image-20220720232449493](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220720232449493.png)

> 随笔记录：僵尸进程的产生是因为父进程没有 wait () 子进程。,所以如果我们自己写程序的话一定要在父进程中通过 wait () 来避免僵尸进程的产生，僵尸进程的产生会导致内存泄漏。子进程僵尸，父进程没回收，父进程退出后僵尸子进程会交给Init进程，Init进程会发现并回收这个僵尸进程，如果父进程一直在运行，子进程一直僵尸，内存就泄漏了。

### 🌵管道读写的四种特殊情况

1. 写端进程一直写，读端进程不读。对应的文件描述符未被关闭

如果管道满了，就要等管道有空闲空间才能继续写，也就是被读端进程读走后才能继续写。简单来说就是**write阻塞**

```c
#include <stdio.h>
#include<unistd.h>
#include<string.h>
#include <stdlib.h>
#include<sys/types.h>
#include <sys/wait.h>
int main()
{
  int pipe_fd[2]={0};
  int ret=pipe(pipe_fd);
  if(ret<0)
  {
    perror("pipe");
    return 1;
  }
  pid_t id=fork();
  if(id==0)
  {
   //  child write
    close(pipe_fd[0]);
      
    const char* msg="hello world!\n";
    int cnt=1;
    while(cnt)//写端进程不断写
    {
      write(pipe_fd[1],msg,strlen(msg));
      printf("child writes the msg:%d\n",cnt);
      cnt++;
    }
      
    close(pipe_fd[1]);
    exit(0);
  }
  else if(id>0)
  {
     // father read 
    close(pipe_fd[1]);
      
    int status=0;
    if(waitpid(id,&status,0)>0)
    {
      printf("wait success!\n");
    }
  }
  else 
  {
    perror("fork");
  }
    
  return 0;
}
```

![image-20220721093754149](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220721093754149.png)

2. 写端进程不写，读端进程一直读。对应的文件描述符未被关闭

读端进程一直读，因为管道里没有数据，读端进程就被挂起了，简单来说就是read阻塞。

```c
#include <stdio.h>
#include<unistd.h>
#include<string.h>
#include <stdlib.h>
#include<sys/types.h>
#include <sys/wait.h>
int main()
{
  int pipe_fd[2]={0};
  int ret=pipe(pipe_fd);
  if(ret<0)
  {
    perror("pipe");
    return 1;
  }
  pid_t id=fork();
  if(id==0)
  {
   //  child write
    close(pipe_fd[0]);
    while(1)//子进程不写数据
    {
      printf("pipe is NULL\n");
      sleep(1);
    }
    exit(0);
  }
  else if(id>0)
  {
     // father read 
    close(pipe_fd[1]);
     char buffer[128];
     while(1) //父进程一直在读
     { 
        ssize_t num=read(pipe_fd[0],buffer,127);
        if(num>0)
        {
          buffer[num]='\0';
          printf("father get the msg from child:%s\n",buffer);
        }
        else if(num==0) 
        {
          printf("piple file close,child quit\n");
          break;
        }
        else 
        {
          perror("read");
        }
     } 
     close(pipe_fd[0]);
    int status=0;
    if(waitpid(id,&status,0)>0)
    {
      printf("wait success!\n");
    }
  }
  else 
  {
    perror("fork");
  }

  return 0;
}

```

> 随笔记录：gdb模式下set listsize n,修改list默认显示的代码行数

![image-20220721100749537](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220721100749537.png)

3. 写端进程写完后被关闭，读端进程还在读。

不会出现write和read阻塞的问题，而是读端发现写端关闭后read直接返回0，然后继续执行后面的代码。

```c
#include <stdio.h>
#include<unistd.h>
#include<string.h>
#include <stdlib.h>
#include<sys/types.h>
#include <sys/wait.h>
int main()
{
  int pipe_fd[2]={0};
  int ret=pipe(pipe_fd);
  if(ret<0)
  {
    perror("pipe");
    return 1;
  }
  pid_t id=fork();
  if(id==0)
  {
   //  child write
    close(pipe_fd[0]);
    
    int cnt=5;
    const char* msg="hello world!\n";
    while(cnt--)
    {
      write(pipe_fd[1],msg,strlen(msg));
      printf("child writes the msg:%d\n",cnt);
      sleep(1);
    }
    close(pipe_fd[1]);
    cnt=3;
    while(cnt--)
    {
      printf("pipe has closed\n");
      sleep(1);
    }
    exit(0);
  }
  else if(id>0)
  {
     // father read 
    close(pipe_fd[1]);
     char buffer[128];
     while(1) { 
        ssize_t num=read(pipe_fd[0],buffer,127);
        if(num>0)
        {
          
          buffer[num]='\0';
          printf("father get the msg from child:%s\n",buffer);
        }
        else if(num==0) 
        {
          printf("piple file close,child quit\n");
          break;
        }
        else 
        {
          perror("read");
        }
     } 
     close(pipe_fd[0]);
    int status=0;
    if(waitpid(id,&status,0)>0)
    {
      printf("wait success!\n");
    }
  }
  else 
  {
    perror("fork");
  }

  return 0;
}

```

![image-20220721101704562](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220721101704562.png)

4. 写端进程一直写，读端进程被关闭。

写的目的不就是读吗，读都被关闭了，写自然也就没有意义了。而写端还在一直写入数据，系统会干掉写端进程。

```c
#include <stdio.h>
#include<unistd.h>
#include<string.h>
#include <stdlib.h>
#include<sys/types.h>
#include <sys/wait.h>
int main()
{
  int pipe_fd[2]={0};
  int ret=pipe(pipe_fd);
  if(ret<0)
  {
    perror("pipe");
    return 1;
  }
  pid_t id=fork();
  if(id==0)
  {
   //  child write
    close(pipe_fd[0]);
    
    int cnt=5;
    const char* msg="hello world!\n";
    while(cnt--)
    {
      write(pipe_fd[1],msg,strlen(msg));
      printf("child writes the msg:%d\n",cnt);
      sleep(1);
    }
    close(pipe_fd[1]);
    cnt=3;
    while(cnt--)
    {
      printf("pipe has closed\n");
      sleep(1);
    }
    exit(0);
  }
  else if(id>0)
  {
     // father read 
    close(pipe_fd[1]);
    close(pipe_fd[0]);
    int status=0;
    if(waitpid(id,&status,0)>0)
    {
      printf("wait success!\n");
    }
  }
  else 
  {
    perror("fork");
  }

  return 0;
}

```

![image-20220721102500499](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220721102500499.png)

略微修改代码，拿到终止子进程的信号。

![image-20220721104514670](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220721104514670.png)

### 🌵管道读写的特点

根据上面几种情况，我们可以窥探出管道的一些特点。

- 管道自带同步机制

> 可以发现管道里有数据才会被读
>
> 管道里没有数据读端进程就会在那等
>
> 管道写满了就不会再写，就在那等待被读，这些都是同步的体现，表现为进程的运行有先后顺序。
>
> 个人理解同步的进程运行起来如同有条件约束一般，比如当管道有数据才去读，这种机制有点“束手束脚”的意思，而不是各运行各的，不会发生管你有没有数据我都去读这种情况。同步机制一般由加锁实现

- 管道是单向通信的，肯定是一个写一个读
- 匿名管道只能保证是具有血缘关系的进程进行通信，常常用于父子。

> linux下的管道命令‘|’指的就是匿名管道，他们有同一个父进程，也就是bash进程。

- 管道是面向字节流的（网络那块会详细阐述面向字节流）
- 管道可以保证一定程度的数据读取的原子性（原子性：事务的不可分割性，一个操作要么被全部执行，要么全部不执行，这个操作也就是原子操作，原子操作一般通过同步机制完成，非原子操作存在线程安全问题，一般通过加锁保证操作的原子性）
- **管道的生命周期随进程**，管道也是文件，进程退出管道自然也会被关闭。

### 🌵管道的大小

```shell
ulimit -a
```

0.5KB*8=4KB

![image-20220721104817801](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220721104817801.png)

**写程序可以验证管道容量大小最大是65526个字节**(64KB)

代码实现上注意写满管道前子进程不能退出了，子进程退出了的话表示读端没了，写端（父进程）就会被系统干掉，~~我当时没注意到这种情况打印到五千多就停了。~~

```c
#include <stdio.h>
#include<string.h>
#include <stdlib.h>
#include<sys/types.h>
#include <sys/wait.h>
#include<unistd.h>
int main()
{
  int pipe_fd[2]={0};
  pipe(pipe_fd);
  pid_t id=fork();
  if(id==0)
  {
    close(pipe_fd[1]);
    while(1)//子进程不能提前退出
    {
      sleep(1);
    }

    close(pipe_fd[0]);
  }
  else
  {   
    close(pipe_fd[0]);
    char c='a';
    int cnt=1;
    while(1)
    {
      write(pipe_fd[1],&c,1);
      printf("%d\n",cnt);
      cnt++;
    }
    close(pipe_fd[1]);
    waitpid(id,NULL,0);

  }
  return 0;
}
```

![image-20220721153501198](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220721153501198.png)

为什么ulimits -a打印的是4KB,我们测试的时候是64KB呢？4KB是最小单元，比如我写入4097个字节，那系统会分配8KB给我们，只是我们只能用4097个字节。

> 参考资料👉[Linux管道的容量大小及管道的数据结构](https://blog.csdn.net/jyy305/article/details/57122788)
>
> 随笔记录：取消43,70行的注释
>
> ![image-20220721111710687](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220721111710687.png)
>
> :43,70 s/^/\/\//g 可以注释43-70行

## 🌴命名管道

匿名管道只能用于两个有亲缘关系的进程通信，如果没有亲缘关系又要通信的话，此时就需要命名管道了。

![image-20220721162609034](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220721162609034.png)

### 🌵创建命名管道

**mkfifo命令**

![image-20220721154338535](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220721154338535.png)

#### 🥝mkfifo函数

 int mkfifo(const char *pathname, mode_t mode);

> 文件路径具有唯一性，所以可以让两个进程看到同一份资源。

![image-20220721155720841](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220721155720841.png)

在当前目录下创建一个管道文件的例子。

```c
#include<stdio.h>
#include<sys/types.h>
#include <sys/stat.h>

int main()
{
  if(mkfifo("./myfifo",0644)<0)
  {
    perror("mkfifo");
    return 1;
  }
  return 0;
}
```

运行效果

![image-20220721160915504](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220721160915504.png)

### 🌵server和client的小demo

server，服务端读。

client，客户端写。

在服务端创建一个管道文件，客户端打开文件后进行写入，服务端再打开文件读取数据就实现了服务端和客户端两个进程的通信。

启动的时候是先启动服务端，因为要创建管道文件。

**server.c**

```c
#include <stdio.h>
#include<unistd.h>
#include <sys/types.h>
#include<sys/stat.h>
#include <fcntl.h>

int main()
{
  if(mkfifo("./myfifo",0644)<0)
  {
    perror("mkfifo");
    return 1;
  }
  int fd=open("myfifo",O_RDWR);
  if(fd<0)
  {
    perror("open");
    return 2;
  }
  while(1)
  {
    char buf[128];
    ssize_t num=read(fd,buf,sizeof(buf)-1);
    buf[num]='\0';
    printf("server has got the msg:%s\n",buf);
    sleep(1);
  }
  return 0;
}
```

client.c

```c
#include <stdio.h>
#include<unistd.h>
#include <sys/types.h>
#include<sys/stat.h>
#include <fcntl.h>
#include <string.h>

int main()
{
  int fd=open("myfifo",O_RDWR);
  if(fd<0)
  {
    perror("open");
    return 1;
  }
  while(1)
  {
    const char* msg="hello world\n";
    write(fd,msg, strlen(msg));
    printf("client has wrote the msg!\n\n");
    sleep(1);
  }
  return 0;

}
```

**Makefile**

```makefile
.PHONY:all
all:client server 

client:client.c
	gcc -o $@ $^

server:server.c
	gcc -o $@ $^

.PHONY:clean
clean:
	rm -f client server
```

运行效果

![image-20220721171251655](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220721171251655.png)

> 命名管道还有很多用途。比如进程遥控，还可以结合进程替换传递命令，等等。

## 🌴匿名管道和命名管道的区别

- 匿名管道用于有亲缘关系的进程，命名管道用于任意两个进程。
- 匿名管道的打开交给了pipe函数，pipe函数会创建并打开。命名管道的创建交给了mkfifo函数，管道的打开交给了open。
- 两者唯一区别就是打开和创建方式不同，创建和打开完成后，两者其实都是一样的。（因为创建和打开的工作就是让两个进程看到一块资源，怎么操作资源就是文件操作的事了）

# 🌲System V IPC

我的理解System V就是一个标准,这个标准下有几种通信方式。

## 共享内存



## 信号量















![image-20220719151054909](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220719151054909.png)

![image-20220719152016120](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220719152016120.png)



![image-20220719153042214](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220719153042214.png)

shm share memory共享内存

![image-20220719153243922](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220719153243922.png)



![image-20220719153622384](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220719153622384.png)

![image-20220719154801571](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220719154801571.png)

![image-20220719155220924](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220719155220924.png)



![image-20220719155355755](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220719155355755.png)

![image-20220719155814181](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220719155814181.png)





![image-20220719155912371](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220719155912371.png)



![image-20220719160830688](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220719160830688.png)

![image-20220719161326855](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220719161326855.png)



![image-20220719161623436](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220719161623436.png)

![image-20220719161718563](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220719161718563.png)



![image-20220719162316112](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220719162316112.png)







![image-20220719162425953](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220719162425953.png)





![image-20220719162554471](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220719162554471.png)

![image-20220719162924649](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220719162924649.png)

![image-20220719162939495](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220719162939495.png)

![image-20220719163037580](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220719163037580.png)

![image-20220719171304725](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220719171304725.png)

![image-20220719171603106](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220719171603106.png)

![image-20220719171811732](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220719171811732.png)

![image-20220719235658639](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220719235658639.png)

![ ](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220720000122172.png)

![image-20220720004215949](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220720004215949.png)

![image-20220720004958182](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220720004958182.png)

![image-20220720005232499](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220720005232499.png)

![image-20220720005417419](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220720005417419.png)





![image-20220720005559630](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220720005559630.png)



![image-20220720005725504](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220720005725504.png)







![image-20220720011752922](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220720011752922.png)



![image-20220720011933017](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220720011933017.png)



![image-20220720093052910](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220720093052910.png)









![image-20220720095806242](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220720095806242.png)



![image-20220720100109236](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220720100109236.png)









![image-20220720100754883](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220720100754883.png)



![image-20220720101535473](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220720101535473.png)



![image-20220720101854875](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220720101854875.png)

![image-20220720102558449](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220720102558449.png)



![image-20220720103117877](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220720103117877.png)

![image-20220720103906920](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220720103906920.png)

