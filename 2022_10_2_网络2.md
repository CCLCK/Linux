- TCP的通信是可靠的,最有名的三次握手,四次挥手

![image-20221011162945555](https://ccl-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20221011162945555.png)

- 粗略的理解一下三次挥手四次握手

创建链接的三次握手:

client:你当我女朋友吧

server:好啊,什么时候

clinet:就现在

断开链接的四次挥手

clinet:我要分手

server:好啊

server:我要分手

client:好啊

- socket编程里TCP用到的主要接口的作用

| 接口    | 作用                     |
| ------- | ------------------------ |
| connect | 发起三次握手             |
| accept  | 将建立好的链接拿到应用层 |
| close   | 对应四次挥手中的两次     |

三次挥手和四次挥手的工作是OS完成的,connect和close只是触发OS去执行三次握手和四次挥手

- TCP是全双工通信,就是client和server可以同时互发数据.udp不是单工的,单工/全双工这些概念都是面向链接时才有的说法.管道和人与人之间讲话都是半双工的,都是你讲一句我讲一句,或者我写了数据才能读这样的,而不存在同时读写.

> [ TCP与UDP的区别_m_xiaoer的博客-CSDN博客_udp是全双工还是半双工](https://blog.csdn.net/m_xiaoer/article/details/72885418)

- 什么是连接?

客户端连接服务器,本质就是连接服务器的OS里的协议栈模块.服务器肯定有多个客户端来连,因为服务器少,客户端多,即1:n的关系,所以服务器的OS上一定会有大量的客户端链接,那自然OS就要把链接管理起来,说到操作系统的管理,自然是先描述再组织,怎么描述?那自然就是结构体.说到这里,大概就能知道建立链接的本质就是在双方的OS创建对应的数据结构并对其进行维护,所以建立链接是有成本的.

```c
//假设维护的结构是这样的
struct link
{
    struct link* prev;
    struct link* next;
    int status;
    int ip.port;
    ...//等等
}
```



- 序列化和反序列化

网络上两台主机发数据,比如主机A要发给主机B一个结构体.

```c
//比如我们定义结构体
struct data
{
 int a,
 int b,
 int c
};
struct data d={1,2,3};
```

我们发送时肯定是不能直接发送结构体,需要先将其序列化,比如把结构体data序列化为["value":1,"value":2,"value":3]这样的格式,再把这种格式发给主机B,主机B再把发过来的数据反序列化得到struct data d={1,2,3};这里的两台主机可以理解为服务器和客户端.常用的序列化的文件格式有json和XML.(json对应python里的字典)

序列化和反序列化的作用:方便网络传输,并且不出错.

> 这里只是简单提一下序列化和反序列化









