

# 信号

学习信号这个新知识，从信号是什么，为什么（有信号），怎么办（信号怎么用）三个角度入手。

## 信号是什么？

> 在计算机科学中，信号是Unix、类Unix以及其他POSIX兼容的操作系统中进程间通讯的一种有限制的方式。它是一种异步的通知机制，用来提醒进程一个事件已经发生。当一个信号发送给一个进程，操作系统中断了进程正常的控制流程，此时，任何非[原子操作](https://baike.baidu.com/item/原子操作/1880992)都将被中断。如果进程定义了信号的处理函数，那么它将被执行，否则就执行默认的处理函数。--百度百科

简单来说，信号就是一种通知机制。想想我们生活里的信号，红灯停绿灯行，红灯“通知”我们现在不能走，得要等绿灯。古代的烽火，通知士兵有敌人等等，这些都是信号。那Linux里的信号呢？生活中很多信号通知的是人，信号通知的就是进程，比如子进程结束后就发一个信号通知父进程我结束了。再比如我们通过键盘发送一个信号告诉进程你要停下来了。

Linux的信号分为普通信号和实时信号，一共有64个，1-31为普通信号，34-64为实时信号，这里主要了解普通信号。

> 32和33被线程库征用了。这里去探究总共有多少个实时信号意义也不大...（有些说33-64，有些说34-63，至于哪种是对的我也不得而知，不过意义也不大）
>
> 我们当前只关注1-31号信号。

- **kill -l查看所有命令。**

![image-20220726164828368](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220726164828368.png)

> 普通信号分别对应的作用👉[Linux信号列表及其详解 ](https://cloud.tencent.com/developer/article/1433358)

## 信号的作用

用于进程间通信。

> 一点碎碎念，如果把这个问题变为探讨为什么有信号，这个问题就变得哲学了起来，百度告诉我信号是linux系统为了响应某些状况而产生的事件，听起来挺抽象的，这就好似问为什么要有红绿灯。。。我大而粗略的认为信号有利于系统与进程的通信，让他们两个更好的交流，是对操作系统有利的一种机制。（就比如红绿灯有利于交通安全）

## 信号的产生

> 信号怎么用，这个问题也很大，所以下面仅是信号的简单入门。

信号的产生有三种方式，可以通过键盘、kill命令和软硬件条件产生。

### 键盘

我们常用的ctrl+c就是典型的向进程发送一个2号信号。

> 信号不同，效果不同。对于相当一部分信号，进程收到后的处理都是终止进程，当然也有一些信号可以暂停进程的，我们也可以自定义进程对某个信号的处理。

```c++
#include <iostream>
#include<unistd.h>
#include<cstdio>
using namespace std;
int main()
{
  while(1)
  {
    printf("ck is a good man!\n");
    sleep(1);
  }
  return 0;
}
```

![image-20220726171318092](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220726171318092.png)

> 常用的还有ctrl+z,ctrl+\等等，ctrl+z对应20号信号，停止进程的运行，ctrl+\对应三号信号，进程收到这个进程退出后会生成一个core文件，core文件是内存的映像，程序崩溃时存储相关信息利于调试找错误（这个之后会提到）

### kill 命令

下面以通过kill命令对死循环的进程发送2号信号为例。

即kill -2 PID.

> kill -信号名字 PID.

![image-20220726173840342](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220726173840342.png)上面这个例子写成kill -SIGINT 5982也可以。





![image-20220722231402136](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220722231402136.png)



![image-20220722231519182](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220722231519182.png)







![image-20220722231626456](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220722231626456.png)



![image-20220722231649030](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220722231649030.png)

![image-20220722231802807](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220722231802807.png)





![image-20220722233026363](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220722233026363.png)



![image-20220723095250687](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220723095250687.png)



![image-20220723095655377](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220723095655377.png)







![image-20220723100215089](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220723100215089.png)





![image-20220723100341023](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220723100341023.png)





![image-20220723100451283](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220723100451283.png)









![image-20220723100808483](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220723100808483.png)



![image-20220723100939826](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220723100939826.png)



kill -9管理员信号    可以对大部分信号自定义捕捉，但是个别无法进行自定义

![image-20220723101222585](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220723101222585.png)



![](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220723101540775.png)









![image-20220723101307873](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220723101307873.png)

![image-20220723101406892](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220723101406892.png)





![image-20220724140315117](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220724140315117.png)



core文件  kill -8+unlimits -a 出现

核心转储

![image-20220724140604382](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220724140604382.png)



线上环境，比如云服务器，核心转储是被关闭的





为什么要有核心转储



 ![image-20220724141128747](C:/Users/ADMIN/AppData/Roaming/Typora/typora-user-images/image-20220724141128747.png)

![image-20220724141715326](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220724141715326.png)









![image-20220724142305198](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220724142305198.png)





![image-20220724142816776](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220724142816776.png)







程序崩溃的本质就是被操作系统检查到了  发送信号直接结束了进程

发信号本质是写信号，改变PCB里的位图

验证core dump



![image-20220724232706338](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220724232706338.png)

![image-20220724234024596](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220724234024596.png)

允许core dump得用unlimits设置

![image-20220724234146857](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220724234146857.png)



关于越界，栈附近可能是我们自己的空间，而可能访问到自己的空间，不是内核的，所以可能越界检查不出来



![image-20220725000205575](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220725000205575.png)

代码角度

![image-20220725000300351](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220725000300351.png)





用kill发信号



![image-20220725000324446](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220725000324446.png)

小结

![image-20220725001035667](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220725001035667.png)



![image-20220725002919128](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220725002919128.png)





1s能跑到多少  不带IO的（带IO的一般就几十万）--》IO是有效率方面的损耗的

![image-20220725003645560](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220725003645560.png)





3s后abort进程

![image-20220725004050180](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220725004050180.png)



![image-20220725004224448](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220725004224448.png)





mykill命令

![image-20220725004805036](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220725004805036.png)



![image-20220725005909579](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220725005909579.png)





![image-20220725224904168](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220725224904168.png)





  ![image-20220725232033536](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220725232033536.png)

![image-20220725232631803](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220725232631803.png)



位图的数据类型 sigset_t

不建议自己手动更改这个数据结构，建议用接口，因为系统版本不同，可能这个数据结构也不同





![image-20220726000402712](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220726000402712.png)











![image-20220726002215210](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220726002215210.png)



![image-20220726002028466](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220726002028466.png)





![image-20220726002541554](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220726002541554.png)





![image-20220726003554550](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220726003554550.png)

 



访问用户空间的状态就是用户态

内核态状态同理





![image-20220726004350113](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220726004350113.png)





内核级页表可以理解为所有进程共享的。

进程的切换本质是在进程上下文中切换。



[Linux 信号表 - wiessharling - 博客园 (cnblogs.com)](https://www.cnblogs.com/wiessharling/p/4105287.html)



[同步和异步的概念 - rainbow70626 - 博客园 (cnblogs.com)](https://www.cnblogs.com/rainbow70626/p/8094199.html)

[细细阅读，3张图带你理解，零拷贝，mmap和sendFile_c++_奔着腾讯去_InfoQ写作社区](https://xie.infoq.cn/article/a34cf4d2c6556d6c81be17303#:~:text=之所以能够减少一次拷贝，就是因为 mmap,直接将磁盘文件数据映射到内核缓冲区，这个映射的过程是基于 DMA 拷贝的，同时用户缓冲区是跟内核缓冲区共享一块映射数据的，建立共享映射之后，就不需要从内核缓冲区拷贝到用户缓冲区了。)

比如输入数据，





![image-20220726101746567](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220726101746567.png)

![image-20220726102508111](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220726102508111.png)



![image-20220726103853654](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220726103853654.png)







![image-20220726104732603](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220726104732603.png)

![image-20220726105212603](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220726105212603.png)



![image-20220726110008402](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220726110008402.png)

sa_mask就是不想在处理的时候让别的信号来打扰他（希望屏蔽别的一些信号）



信号产生多次 只有一个位图

![image-20220726110810459](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220726110810459.png)





![image-20220726111311304](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220726111311304.png)



![image-20220726111401288](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220726111401288.png)







普通信号允许丢失 实时信号不会

![image-20220726111949958](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220726111949958.png)









父子进程共享代码



重入，重复进入

![image-20220726112732522](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220726112732522.png)



![image-20220726113140918](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220726113140918.png)

![image-20220726113224148](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220726113224148.png)

vlotile

g++编译

![image-20220726150847422](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220726150847422.png)



gcc编译

![image-20220726151553260](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220726151553260.png)



![image-20220726151816529](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220726151816529.png)



volatile一旦修饰变量  保证了内存变量的可见性。相当于告诉编译器你每次读这个变量的值，都先把变量从内存拷贝到寄存器中再去读，而不是直接从寄存器中读。



![image-20220726153406542](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220726153406542.png)





![image-20220726154745531](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220726154745531.png)





![image-20220726155024674](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220726155024674.png)





































