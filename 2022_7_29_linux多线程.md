[toc]



从线程是什么，为什么要用和怎么用出发。下面探讨的都是linux下的线程

# 线程是什么

> [线程（计算机术语）_百度百科 (baidu.com)](https://baike.baidu.com/item/线程/103101)

线程是进程的一个执行分支，是在进程内部运行的一个执行流，是操作系统进行运算调度的最小单位。

在linux里我们也把线程成为轻量级进程（LWP，LightWeightProcess）,因为linux里其实没有真正的线程，线程是通过进程模拟出来的（在内核里都是一个个的task_struct)。

没学线程前我们说进程是操作系统最小的调度单位，因为那时我们写的代码都是单线程的，一个进程只有一个执行流，所以那么说也没错，准确一点就是线程是操作系统调度的最小单位。

单执行流

![image-20220804103802340](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220804103802340.png)

多执行流

![image-20220804104624107](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220804104624107.png)

通过上面两张图得出的一些结论，同时补充一些概念：

- 站在CPU的角度，进程与线程没有任何区别，它看到的都是task_struct,这也是为什么线程在linux里也叫轻量级进程，也说明linux下没有真正意义上的线程。简单来说，CPU对线程0感知。
- 线程之间是共用一个地址空间的，这说明比起进程之间的切换，线程的切换更加轻量级。因为进程切换可能要保存页表、地址空间的数据甚至缓存的数据等等，而线程之间切换时这些都不用动，自然切换的代价也比较小。
- 进程：线程=1：n，说明系统内有大量的线程，所以操作系统必定要把线程管理起来，说明如果一个系统支持真正的线程，比如windows，那必然是有一个结构（TCB）来描述这个线程的属性，并且将其组织起来，但是往往比较复杂，linux下虽然没有真正的线程，但是优点就是简单。
- linux下没有真正意义的线程，这就说明OS不可能在系统层面提供操作线程的接口，而是一些封装好给用户的轻量级接口。
- CPU调度的都是线程，即线程是CPU调度的最小单位
- 站在系统的角度，进程是承担系统资源的基本单位。因为第二个线程用的资源都是第一个线程申请好的。
- 线程在进程内部运行，这句话的意思是线程在进程地址空间内运行。
- 通过页表可以看到物理内存，也即真正的资源，同时说明只要划分页表我们就可以让线程看到进程的部分资源。
- 关于页表，页表不仅仅记录了虚拟地址与物理地址的映射，还有一些别的属性，如权限，是否命中等等，这说明页表的大小不是一个字节就能记录的。一般32位的机器物理内存是4G，说明有2^32^这么多个地址要映射，即页表要记录2^32^个映射关系，表示每一个映射关系需要的字节都大于1，说明页表整体大小大于4G，放不进内存，此时就引出了二级页表。负责这块的硬件就是MMU，具体的了解可以查询二级页表的相关资料。
- 线程数越多越好吗？并不是，建议与计算机的核数相当。线程过多会导致大部分时间花在调度上，而没有花在线程的执行上，有点买椟还珠的意思。          
- 没有线程替换，线程替换就是整个进程被替换。           
- CPU不需要线程的概念，linux下线程这个概念是给用户的，因为用户需要多线程编程       
- 用户层通过TCB来知道线程的id、状态、优先级和其他属性，用来进行用户级的线程管理。TCB不由内核维护，而是由用户空间维护。               

> 随笔记录:[一个程序被加载到内存，系统就创建了一个进程。请问这句话什么意思？为什么要先加载到内存？ (sogou.com)](https://wenwen.sogou.com/question/q710120053.htm)
>
> ![image-20220804112357220](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220804112357220.png)



# 线程常见接口使用

线程的优缺点放在最后，直接贴在这里有点太抽象了。

相关接口的使用细节可以用man命令查询，下面直接贴基本用法。

## 相关概念补充

线程之间有共享进程数据，但也有独有的资源。

共享的资源：进程代码段、进程的公有数据，进程所拥有的的资源。

**独有的资源：**寄存器内的数据，线程的独立栈，自己的状态（如自己的线程id、调度优先级、信号屏蔽字、errno等）。**可以概括为<font color=red>上下文数据和独立的栈结构</font>，上下文数据说明线程线程是可以被切换的，独立的栈结构说明线程是独立运行的。**

> 进程地址空间里不是有一个栈了，那这个独立栈在哪？在共享区。
>
> ![image-20220805104604626](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220805104604626.png)
>
> tid1和tid2两个值本质是一个地址，进程地址空间内的栈只能被主线程用，别的线程有自己的独立栈，在共享区内。
>
> 删除线程就是删掉内核级别的LWP，再释放共享区里的资源（数据结构）。

一个线程异常终止，会导致整个进程终止。比如线程中出现除零错误、野指针越界等，进程就会触发信号机制，系统就发送一个信号终止进程（因为信号是针对进程而不是针对线程的）。

了解：vfork()的使用，简单来说，创建子进程并让父进程阻塞，并且子进程共享父进程的地址空间，一般vfork出来的子进程都是为了替换，因为这种替换后不需要父进程的数据也就不需要像fork()一样去拷贝父进程的进程地址空间。具体使用可以查询资料和文档。

## pthread_create创建线程

创建一个新线程，成功返回0，失败返回一个错误码。

    #include <pthread.h>
    int pthread_create(pthread_t *thread, const pthread_attr_t *attr,void *(*start_routine) (void *),
    	 void *arg);
    Compile and link with -pthread.

thread:输出型参数，返回创建的线程的id。

attr:设置线程的属性，attr为NULL表示默认属性

start_routine：函数指针，表示线程启动后要执行的函数。函数返回值和参数都为void*。

> 参数是void*,"void * "被称为万能指针，可以帮助接收各种参数。

arg:传给线程启动函数的参数。

**编译时要加lpthread选项**，表示链接到pthread库

> - 关于pthread_t类型，typedef uintptr_t pthread_t;uintptr_t是unsigned long int。但是我们不应该这么做，因为pthread_t是一个不透明的类型，根据平台不同实现也不同，所以不应该用无符号长整形去定义它。
>
> 这里我们只需知道线程ID的类型是pthread_t。判断两个线程ID相等也应该用相应的接口，而不是“==”，尽管线程ID打印出来是一个数字。
>
> - 关于“Compile and link with -pthread.”
>
> ![image-20220805101751853](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220805101751853.png)



### 例子

创建一个新线程，主线程每隔1s打印一次，新线程每隔2s打印一次。

```cpp
#include <iostream>
#include <pthread.h>
#include<unistd.h>
using namespace std;

void* routine(void* args)//新线程执行的函数
{
  while(true)
  {
    cout<<(char*)args<<endl;
    sleep(2);
  }
  return nullptr;
}

int main()
{
  pthread_t tid;
  pthread_create(&tid,nullptr,routine,(void*)"thread 1");//创建新线程

  while(true)
  {
    cout<<"main thread is running"<<endl;
    sleep(1);
  }
  return 0;
}
```

![image-20220804161000876](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220804161000876.png)

## pthread_self()获取线程自身id

获取当前线程的id，函数调用总是成功，返回值为线程id。

```c
#include <pthread.h>

pthread_t pthread_self(void);
Compile and link with -pthread.
```

### 例子1

每隔1s打印主线程和新线程的线程id

```cpp
#include <iostream>
#include <pthread.h>
#include<unistd.h>
using namespace std;

void* routine(void* args)
{
  while(true)
  {
    cout<<"thread1 id: "<<pthread_self()<<endl;
    sleep(1);
  }
  return nullptr;
}

int main()
{
  pthread_t tid;
  pthread_create(&tid,nullptr,routine,(void*)"thread 1");

  while(true)
  {
    //cout<<"main thread is running"<<endl;
    cout<<"main thread id: "<<pthread_self()<<endl;
    sleep(1);
  
  }
  return 0;
}
```

![image-20220804171207728](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220804171207728.png)

### ps-aL命令查看系统轻量级进程

```shell
ps -aL  //这里查看的进程是上面的例子
```

可以看到进程id相同，因为两个线程属于同一个进程，主线程id和新线程id不同，主线程的PID和LWP相同。

![image-20220804171503949](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220804171503949.png)

可以看到例子里打印的线程pthread_t表示的线程ID和LWP表示的线程ID不同，直接给结论，LWP是系统唯一标识线程的ID，**pthread_t变量的值本质是进程地址空间上共享区的一个起始地址，是用户层的线程id。**

拿到用户级别的线程id，就可以在库里找到线程相关属性，包括线程的独立栈。

### 例子2

循环创建多个进程，利用数组+指针让线程调用的函数知道自己是第几个线程。

```cpp
#include <iostream>
#include <pthread.h>
#include<unistd.h>
using namespace std;

void* routine(void* args)//参数为void*可以帮助接收各种参数
{
  while(true)
  {
    cout<<"thread"<<*(int*)args<<" id: "<<pthread_self()<<endl;
    sleep(2);
  }
  return nullptr;
}

int main()
{
  pthread_t tid[5];
  for(int i=0;i<5;i++)
  {
    int* p=new int(i);
     pthread_create(tid+i,nullptr,routine,(void*)p);

  }

  while(true)
  {
    //cout<<"main thread is running"<<endl;
    cout<<"main thread id: "<<pthread_self()<<endl;
    sleep(2);
  
  }
  return 0;
}
```

![image-20220805110033792](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220805110033792.png)

## pthread_join()等待线程

### 为什么要等待线程呢？

- 防止内存泄漏（一直占着资源没释放）
- 让main线程最后退出（main没了别的线程还在跑不合理）
- 获的新线程的退出码（任务做的怎么样）

和等待进程类似，我们创建线程是给了他对应的任务，我们是需要知道这个线程把这个任务做的怎么样的，此外，已经退出的线程空间没有被释放，仍然会在进程的地址空间内占用着资源，可以保证创建新的线程不会复用旧线程的地址空间。

> 不等待会怎么样？资源一直没有被回收，造成类似僵尸进程的问题。

等待的时候要不要考虑线程崩溃的问题？不需要，线程崩了表示进程崩了。

### 接口使用

pthread_join()等待线程，成功返回0，失败返回错误码。

```c
#include <pthread.h>

int pthread_join(pthread_t thread, void **retval);

Compile and link with -pthread.
```

第一个thread传进程标识符。

第二个传参数retval传二级指针，这个指针是一个输出型参数，可以获取进程的退出码，也可以获取更加详细的信息，比如用结构体描述退出信息。

> 线程执行的函数routine的返回值是void *，这说明返回值如果是数字（退出码）的话那就是void *,更改void *的值应该用void ** ，所以第二个参数为二级指针。

- 注意pthread_join是**阻塞等待**的，我们可以选择所有线程运行完了等待所有线程，也可以选择运行一个线程就等待一个线程。具体情况具体分析。

- 如果不关心线程退出的状态，第二个参数传空指针即可。

### 例子

创建五个线程，用结构体来描述退出信息，主线程等待并获取退出信息。

```cpp
#include <iostream>
#include <pthread.h>
#include<unistd.h>
#include<string>
using namespace std;

struct exit_code
{
  int code;
  string info;
};

void* routine(void* args)
{
  int cnt=3;
  while(cnt--)
  {
    cout<<"thread"<<*(int*)args<<" id: "<<pthread_self()<<" cnt: "<<cnt<<endl;
    sleep(1);
  }
  exit_code* p=new exit_code();
  p->code=10;
  p->info="thread quit normal!";
  return p;
}

int main()
{
  pthread_t tid[5];
  for(int i=0;i<5;i++)
  {
    int* p=new int(i);
    pthread_create(tid+i,nullptr,routine,(void*)p);
//    void* st=nullptr;//初始化一下,这里是一个线程跑完就等一个线程
//    创建一个线程后，主线程一直阻塞在这，不会再创建下一个进程，所以一个线程跑完等待完了才会创建下一个进程
//    if(pthread_join(tid[i],&st)==0)
//    {
//      cout<<"thread exit code: "<<((exit_code*)(st))->code<<" "<<((exit_code*)(st))->info<<endl;
//    }
  }
//跑完所有线程后集中等待并获取退出码信息，同时也保证了主线程最后退出
 for(int i=0;i<5;i++)
 {
    void* st=nullptr;//初始化一下
    if(pthread_join(tid[i],&st)==0)
    {
      cout<<"thread exit code: "<<((exit_code*)(st))->code<<" "<<((exit_code*)(st))->info<<endl;
    }
 }
  return 0;
}
```



![image-20220805160100552](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220805160100552.png)

> 如果想知道具体等待的是哪个进程可以在结构体传入线程ID。

## pthread_exit()终止线程

### 终止线程的方法

- return
- pthread_exit
- pthread_cancel

不能用exit退出，exit是用来退出进程的

### 接口使用

```c
pthread_exit - terminate calling thread
#include <pthread.h>
void pthread_exit(void *retval);
Compile and link with -pthread.
```

一个参数:指针retval。这个指针不能指向局部变量，不然线程退出局部变量那块空间也被“销毁”了。

### 例子

```cpp
#include <iostream>
#include <pthread.h>
#include<unistd.h>
#include<string>
using namespace std;

struct exit_code
{
  int code;
  string info;
};

void* routine(void* args)
{
  int cnt=3;
  while(cnt--)
  {
    cout<<"thread"<<*(int*)args<<" id: "<<pthread_self()<<" cnt: "<<cnt<<endl;
    sleep(1);
  }
  pthread_exit((void*)10);//设置退出码
}

int main()
{
  pthread_t tid[5];
  for(int i=0;i<5;i++)
  {
    int* p=new int(i);
    pthread_create(tid+i,nullptr,routine,(void*)p);
  }

 for(int i=0;i<5;i++)
 {
    void* ret=nullptr;//初始化一下
    if(pthread_join(tid[i],&ret)==0)
    {    
      cout<<"thread exit code: "<<(int)(ret)<<endl;
    }
 }

  return 0;
}
```

![image-20220805162623964](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220805162623964.png)

## pthread_cancel()取消执行中的线程

```c
pthread_cancel - send a cancellation request to a thread

#include <pthread.h>
int pthread_cancel(pthread_t thread);

Compile and link with -pthread.
```

参数thread表示要取消的线程ID

调用成功返回0，否则返回非0、

- cancel本身具有一定的延时性，并不是立即处理的，所以主线程取消其他线程时得先保证其他线程跑起来了

- 如果一个线程被其他线程pthread_cancel异常终止掉，线程函数的返回值会被设定为PTHREAD_CANCELED，PTHREAD_CANCELED本质是一个宏

  ```c
  #define PTHREAD_CANCELED ((void *) -1)
  ```

### 例子

创建五个进程，2s后取消后三个线程。

```cpp
#include <iostream>
#include <pthread.h>
#include<unistd.h>
#include<string>
using namespace std;

void* routine(void* args)
{
  int cnt=3;
  while(cnt--)
  {
    cout<<"thread"<<*(int*)args<<" id: "<<pthread_self()<<" cnt: "<<cnt<<endl;
    sleep(1);
  }
    pthread_exit((void*)10);
}

int main()
{
  pthread_t tid[5];
  for(int i=0;i<5;i++)
  {
    int* p=new int(i);
    pthread_create(tid+i,nullptr,routine,(void*)p);

  }
 sleep(2);//让线程都跑起来，不然新线程可能被创建了，但是还没有被调度，导致取消出问题
  for(int i=2;i<5;i++)
  {
    pthread_cancel(tid[i]);
  }
 for(int i=0;i<5;i++)
 {
    void* ret=nullptr;//初始化一下
    if(pthread_join(tid[i],&ret)==0)
    {
      cout<<"thread join success "<<endl;
    }
 }

  return 0;
}
```

![image-20220805165025012](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220805165025012.png)

### 例子2

子线程干掉主线程导致主线程僵尸。此时如果子线程一直在跑就会导致内存泄漏（要模拟这个情况加上一个死循环即可）

```cpp
#include <iostream>
#include <pthread.h>
#include<unistd.h>
#include<string>
using namespace std;

pthread_t main_thread;
void* routine(void* args)
{
  int cnt=3;
  while(cnt--)
  {
    cout<<"thread"<<*(int*)args<<" id: "<<pthread_self()<<" cnt: "<<cnt<<endl;
    sleep(1);
    pthread_cancel(main_thread);//干掉主线程
  }
    pthread_exit((void*)10);
}

int main()
{
  main_thread=pthread_self();
  pthread_t tid[5];
  for(int i=0;i<5;i++)
  {
    int* p=new int(i);
    pthread_create(tid+i,nullptr,routine,(void*)p);

  }
 sleep(2);
  for(int i=2;i<5;i++)
  {
    pthread_cancel(tid[i]);
  }
 for(int i=0;i<5;i++)
 {
    void* ret=nullptr;//初始化一下
    if(pthread_join(tid[i],&ret)==0)
    {
      cout<<"thread join success "<<endl;
    }
 }

  return 0;
}
```

左边是运行结果，右边是监控脚本

```Shell 
while :; do ps -aL |head -1 &&ps -aL |grep myproc; sleep 1; echo “############”; done
```

![image-20220805170214539](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220805170214539.png)

> 随笔记录：进程为什么独立？因为有自己独立的地址空间 页表等。

## pthread_detach()分离线程

默认情况下，新创建的线程是joinable的，线程退出后，需要用pthread_join等待线程释放资源，如果不关心线程的返回值，join就是一种负担，此时我们可以告诉系统线程退出时自动释放资源。告诉系统线程退出时的操作就是分离。

**分离的本质是让主线程不用再join新线程，让新线程退出的时候自动回收资源**

### 接口使用

```c
pthread_detach - detach a thread
    
#include <pthread.h>
int pthread_detach(pthread_t thread);

Compile and link with -pthread.

```

一个参数：分离的线程ID

- 一个分离的线程不应该被等待，被等待的结果是未定义的，可能成功有可能不成功。
- 线程设置为分离状态，如果该线程崩了进程一样会崩。

### 例子

```cpp
#include <iostream>
#include <pthread.h>
#include<unistd.h>
#include<string>
using namespace std;

void* routine(void* args)
{
   pthread_t(pthread_self());
   int cnt=3;
  while(cnt--)
  {
    cout<<"new thread is running "<<endl;
    sleep(1);
  }
  return (void*)10;
}

int main()
{
  pthread_t tid;
  pthread_create(&tid,nullptr,routine,nullptr);
  while(true);//不让主线程return 0，不然进程直接结束了
  return 0;
}
```

![image-20220805172952290](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220805172952290.png)

> linux里主线程return 0结束的话，会自动结束其进程。
>
> [linux下主线程return 0和pthread_exit(NULL)的区别](https://www.cnblogs.com/Stephen-Qin/p/12730670.html#:~:text=1.当linux和Windows中%2C主线程以return 0结束时%2C程序会在主线程运行完毕后结束.,2.当linux中%2C主线程以pthread_exit (NULL)作为返回值%2C则主线程会等待子线程.)

# 线程同步和互斥

## 相关概念

- 临界资源：多线程执行流共享的资源。（即多个线程都能看到的同一份资源）

- 临界区：访问临界资源的代码

- 互斥：任何时候保证只有一个执行流进入临界区访问临界资源，可以保护临界资源

- 原子性：不能被打断的操作，对于一个具有原子性的操作来说，要么做了要么没做

- 我们借助锁来实现互斥进而达到保护临界资源的效果。

  



## 售票例子

定义一个全局变量，所有线程都可以访问，那全局变量就是一个临界资源，对全局变量做的修改，如++，--，就有风险，因为++和--不是原子性的。（从汇编上可以知道++和--都对应三条汇编代码，说明是可以打断的）

```c
//全局变量a++对应的三句汇编指令
mov     eax, DWORD PTR a[rip]
add     eax, 1
mov     DWORD PTR a[rip], eax
```

把这里的全局变量a换成售票时的票会发生什么？

**下面创建五个线程模拟抢票时的场景。**

> 票数++需要经过以下几个步骤：tickets从内存写入寄存器，CPU对寄存器里的tickets运算，算好的结果再写回内存，这三步都可能被中断，所以访问tickets这个临界资源是不安全的。
>
> 下面寄存器和CPU之间的箭头表示的是运算，不代表数据的拷贝。
>
> ![image-20220805231808907](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220805231808907.png)
>
> 如果tickets是1，CPU算完后在写回内存这一步被打断了，然后寄存器2相关的线程进来，把tickets改成了999，别的线程再看tickets本来应该是0的却被写成了999，就出现了问题。

```c++
#include <iostream>
#include <pthread.h>
#include<unistd.h>
#include<string>
using namespace std;

int tickets=100 ;//临界资源
void* routine(void* args)
{
  while(1)
  {
    if(tickets>0)
    {
      usleep(30000);//原因在这
      printf("thread 0x%x: get a ticket %d\n",pthread_self(),tickets);
      tickets--;
    }
    else 
    {
      break;
    }
  }
  printf("thread 0x%xquit! ticket %d\n",pthread_self(),tickets);
  return (void*)10;
}

#define NUM 5
int main()
{
  pthread_t tid[NUM];
  for(int i=0;i<NUM;i++)
  {
    pthread_create(tid+i,nullptr,routine,nullptr);
  }

  for(int i=0;i<NUM;i++)
  {
    pthread_join(tid[i],nullptr);
  }
  return 0;
}
```

![image-20220805224031925](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220805224031925.png)

出现了**负数**，显然不合理。这就是**典型的多线程切换的时候因为数据交叉操作导致的数据不一致问题**。OS在内核态返回用户态的时候进行线程切换。这种现象的本质是ticket--不是原子性的。

本质就是多个执行流进入了if语句。

> 具体原因是因为抢票前睡了一下，系统就切到别的线程了，然后别的线程抢完票后票数已经小于0了，此时刚才睡的线程醒了过来又抢，自然就是负数了。举个例子，线程1进入了if语句开始了睡眠，切到了线程2,2去抢票，抢完后票数小于0，线程1苏醒，此时线程1已经在if语句里面，再去抢票票数就是负数了。

## 互斥量pthread_mutex_t

为了解决这种数据不一致的问题，我们引入了锁。下面借助锁来解决这个问题，其实就是保证一次只有一个执行流访问临界区。

在linux里这把锁就叫互斥量。下面主要是锁的使用。

可以把临界区比作一个房间，一个人（执行流）进了临界区就上锁，那别的人都不能进来了，此时只有这一个人可以访问临界资源，其余人（执行流）全在门外等着解锁。用锁的代价很大，所以上锁和解锁的方式就挺有讲究的。

~~在内核里找互斥量的时候发现pthread_mutex_t被封装过了，不太好找~~

### pthread_mutex_init和pthread_mutex_destroy

锁使用前先要初始化，用完也要销毁。

```c
pthread_mutex_destroy, pthread_mutex_init - destroy and initialize a mutex

#include <pthread.h>
int pthread_mutex_destroy(pthread_mutex_t *mutex);
int pthread_mutex_init(pthread_mutex_t *restrict mutex,
                       const pthread_mutexattr_t *restrict attr);
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
```

pthread_mutex_init的第一个参数是一个互斥量的指针，第二个参数attr表示属性，传NULL表示默认的属性。成功返回0，失败返回错误码。

pthread_mutex_init的参数是一个互斥量的指针，成功返回0，失败返回错误码。

此外，除了用pthread_mutex_init进行动态分配的初始化，还有一种静态分配的方法：、

```c
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;//PTHREAD_MUTEX_INITIALIZER本质是一个宏
```

> 随笔记录：线程A的时间片到了，CPU的寄存器里还有数据，这部分数据就称作上下文数据，也就是临时数据
>
> 寄存器是线程共享的，数据是私有的。

### pthread_mutex_lock和pthread_mutex_unlock

上锁和解锁

```c
pthread_mutex_lock, pthread_mutex_trylock, pthread_mutex_unlock - lock and unlock a mutex

#include <pthread.h>

int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_trylock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex)
```

> 关于 pthread_mutex_trylock会尝试对互斥量加锁，如果互斥量已经上锁了。函数调用失败，否则调用成功返回0

### 解决票数为负数的问题

```c++
#include <iostream>
#include <pthread.h>
#include<unistd.h>
#include<string>
using namespace std;

pthread_mutex_t lock;
int tickets=100 ;
void* routine(void* args)
{
  while(1)
  { 
    pthread_mutex_lock(&lock);
    if(tickets>0)
    {
      usleep(30000);
      printf("thread 0x%x: get a ticket %d\n",pthread_self(),tickets);
      tickets--;
      pthread_mutex_unlock(&lock);
    }
    else 
    {
      pthread_mutex_unlock(&lock);//这必须解锁，不然的话可能上了锁没解锁，导致别人都不能进来了。
      break;
    }
  }
  printf("thread 0x%xquit! ticket %d\n",pthread_self(),tickets);
  return (void*)10;
}

#define NUM 5
int main()
{
  pthread_mutex_init(&lock,nullptr);
  pthread_t tid[NUM];
  for(int i=0;i<NUM;i++)
  {
    pthread_create(tid+i,nullptr,routine,nullptr);
  }

  for(int i=0;i<NUM;i++)
  {
    pthread_join(tid[i],nullptr);
  }
  pthread_mutex_destroy(&lock);
  return 0;
}
```



### 相关概念补充

锁的存在是为了保护临界资源

锁的本身就是一种临界资源 ，那谁来保护锁？只需保证lock和unlock是原子的即可。











![image-20220802100601053](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220802100601053.png)

![image-20220802100825553](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220802100825553.png)



![image-20220802101005495](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220802101005495.png)









01两种状态

![image-20220802105538740](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220802105538740.png)

1已经被拿到了x进程的上下文当中 别的进程拿不到了 别的进程再去xchgb只能拿到0  除非释放锁把1还回来

![image-20220802105412456](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220802105412456.png)







申请对方的 又不释放自己的 死锁

请求你的锁 又不释放自己的锁

![image-20220802131151422](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220802131151422.png)

 



![image-20220802132021577](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220802132021577.png)







![image-20220802151119120](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220802151119120.png)





![image-20220802152808083](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220802152808083.png)





死锁段子

你需要工作经历才能找到工作

![image-20220802153826046](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220802153826046.png)



![image-20220802153833166](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220802153833166.png)



![image-20220802161622836](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220802161622836.png)



![image-20220802164008355](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220802164008355.png)



![image-20220802164417578](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220802164417578.png)

![image-20220802164455191](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220802164455191.png)



![image-20220802165003193](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220802165003193.png)



把唤醒一个换成唤醒一批

![image-20220802171459690](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220802171459690.png)

![image-20220802170715259](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220802170715259.png)

![image-20220802172516656](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220802172516656.png)

![image-20220803100932364](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220803100932364.png)

数据满了还往里写就会造成覆盖问题 导致数据的二义性，队列为空还去读 读到的就是旧数据了，也是有问题的



.hpp 把声明和实现写一起

![image-20220803102046542](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220803102046542.png)









![image-20220803102651461](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220803102651461.png)

![image-20220803102636867](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220803102636867.png)



![image-20220803110314312](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220803110314312.png)



![image-20220803110900351](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220803110900351.png)



![image-20220803111017669](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220803111017669.png)



![image-20220803112215648](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220803112215648.png)

![](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220803113256689.png)

最后

![image-20220803113741926](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220803113741926.png)

![image-20220803113550478](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220803113550478.png)





![image-20220803114246754](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220803114246754.png)

![image-20220803114301228](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220803114301228.png)

![image-20220803151307524](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220803151307524.png)

![image-20220803151456451](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220803151456451.png)



多生产多消费

![image-20220803152058253](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220803152058253.png)



![image-20220803155725869](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220803155725869.png)

![image-20220803160236873](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220803160236873.png)



![image-20220803161351171](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220803161351171.png)





![image-20220803161741634](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220803161741634.png)

![image-20220803162129714](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220803162129714.png)



![image-20220803163534309](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220803163534309.png)





![image-20220803163645985](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220803163645985.png)

![image-20220803163850072](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220803163850072.png)

![image-20220803164437514](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220803164437514.png)

![image-20220803164846479](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220803164846479.png)



![image-20220803165046299](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220803165046299.png)



![image-20220803165752752](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220803165752752.png)



![image-20220803170504852](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220803170504852.png)



![image-20220803170936705](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220803170936705.png)



![image-20220803171134349](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220803171134349.png)



![image-20220803215226751](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220803215226751.png)



![image-20220803215439360](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220803215439360.png)

 

![image-20220803215901652](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220803215901652.png)





![image-20220803222742756](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220803222742756.png)



 





![image-20220803223437730](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220803223437730.png)

加锁 因为p_index++

维护生产者与生产者 消费者与消费者的关系

![image-20220803224058560](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220803224058560.png)





![image-20220803232621964](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220803232621964.png)



![image-20220803232747693](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220803232747693.png)





 ![image-20220804000624452](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220804000624452.png)



![image-20220804001228300](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220804001228300.png)



















































![image-20220729130325143](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220729130325143.png)

![image-20220729130313212](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220729130313212.png)

![image-20220729125800585](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220729125800585.png)

一个线程出问题导致进程退出 这也是为什么说线程降低了程序的健壮性







[面试必问的线程池，你懂了吗？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/150057783)





















